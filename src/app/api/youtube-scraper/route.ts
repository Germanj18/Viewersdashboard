import { NextRequest, NextResponse } from 'next/server';

interface YouTubeData {
  viewers: number;
  isLive: boolean;
  title: string;
  status: 'success' | 'error';
  message?: string;
  timestamp: string;
  url: string;
}

export async function POST(request: NextRequest) {
  try {
    const { url } = await request.json();
    
    if (!url) {
      return NextResponse.json({
        status: 'error',
        message: 'URL de YouTube requerida',
        viewers: 0,
        isLive: false,
        title: '',
        timestamp: new Date().toISOString(),
        url: ''
      }, { status: 400 });
    }

    // Validar que sea una URL de YouTube
    const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/;
    if (!youtubeRegex.test(url)) {
      return NextResponse.json({
        status: 'error',
        message: 'URL de YouTube inv√°lida',
        viewers: 0,
        isLive: false,
        title: '',
        timestamp: new Date().toISOString(),
        url
      }, { status: 400 });
    }

    console.log('üîç Iniciando scraping de YouTube:', url);
    console.log('üåê Entorno:', process.env.NODE_ENV);
    console.log('üè¢ Vercel:', process.env.VERCEL ? 'S√≠' : 'No');

    // Headers m√°s robustos para evitar detecci√≥n
    const headers = {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
      'Accept-Language': 'es-ES,es;q=0.9,en;q=0.8',
      'Accept-Encoding': 'gzip, deflate, br',
      'Connection': 'keep-alive',
      'Upgrade-Insecure-Requests': '1',
      'Cache-Control': 'no-cache',
      'Sec-Fetch-Dest': 'document',
      'Sec-Fetch-Mode': 'navigate',
      'Sec-Fetch-Site': 'none',
      'Sec-Fetch-User': '?1',
      'DNT': '1'
    };

    // Timeout m√°s largo para producci√≥n
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15 segundos

    try {
      // Hacer request a YouTube con headers mejorados
      const response = await fetch(url, {
        headers,
        method: 'GET',
        signal: controller.signal,
        // Agregar configuraci√≥n adicional para evitar caching
        cache: 'no-store'
      });

      clearTimeout(timeoutId);

      console.log('üì° Response status:', response.status);
      console.log('üì° Response headers:', Object.fromEntries(response.headers.entries()));

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const html = await response.text();
      console.log('üìÑ HTML length:', html.length);
      
      // Verificar si el HTML parece v√°lido
      if (!html || html.length < 1000) {
        throw new Error('Respuesta de YouTube demasiado corta o vac√≠a');
      }

      // Verificar si YouTube nos est√° bloqueando
      if (html.includes('Our systems have detected unusual traffic') || 
          html.includes('blocked') || 
          html.includes('captcha')) {
        throw new Error('YouTube est√° bloqueando el acceso (detecci√≥n de bot)');
      }
      
      // Extraer informaci√≥n del HTML
      const result = extractYouTubeData(html, url);
      
      console.log('‚úÖ Scraping completado:', result);
      
      return NextResponse.json(result);

    } catch (fetchError) {
      clearTimeout(timeoutId);
      
      if (fetchError instanceof Error && fetchError.name === 'AbortError') {
        throw new Error('Timeout: YouTube tard√≥ demasiado en responder');
      }
      
      throw fetchError;
    }

  } catch (error) {
    console.error('‚ùå Error en scraping de YouTube:', error);
    
    let errorMessage = 'Error desconocido';
    if (error instanceof Error) {
      errorMessage = error.message;
      
      // Agregar contexto espec√≠fico para errores comunes en producci√≥n
      if (errorMessage.includes('fetch')) {
        errorMessage += ' (Posible bloqueo de red en producci√≥n)';
      } else if (errorMessage.includes('timeout') || errorMessage.includes('Timeout')) {
        errorMessage += ' (YouTube responde lento desde servidor)';
      } else if (errorMessage.includes('blocked') || errorMessage.includes('unusual traffic')) {
        errorMessage += ' (YouTube detect√≥ y bloque√≥ el scraping)';
      }
    }
    
    return NextResponse.json({
      status: 'error',
      message: errorMessage,
      viewers: 0,
      isLive: false,
      title: '',
      timestamp: new Date().toISOString(),
      url: '',
      environment: process.env.NODE_ENV,
      isVercel: !!process.env.VERCEL
    }, { status: 500 });
  }
}

function extractYouTubeData(html: string, url: string): YouTubeData {
  try {
    console.log('üîç Analizando HTML para extracci√≥n de datos...');
    
    // Extraer t√≠tulo del video con m√∫ltiples patrones
    let title = '';
    
    // Patr√≥n 1: Meta property og:title
    const ogTitleMatch = html.match(/<meta property="og:title" content="([^"]+)"/i);
    if (ogTitleMatch) {
      title = ogTitleMatch[1].trim();
    }
    
    // Patr√≥n 2: Title tag tradicional
    if (!title) {
      const titleMatch = html.match(/<title[^>]*>([^<]+)<\/title>/i);
      if (titleMatch) {
        title = titleMatch[1].replace(' - YouTube', '').trim();
      }
    }
    
    // Patr√≥n 3: JSON data
    if (!title) {
      const jsonMatches = html.match(/var ytInitialData = ({.*?});/);
      if (jsonMatches) {
        try {
          const data = JSON.parse(jsonMatches[1]);
          const foundTitle = findTitleInObject(data);
          if (foundTitle) title = foundTitle;
        } catch (e) {
          console.warn('Error parseando ytInitialData para t√≠tulo:', e);
        }
      }
    }

    console.log('üìù T√≠tulo extra√≠do:', title || 'No encontrado');

    // Buscar indicadores de stream en vivo con m√°s patrones
    const liveIndicators = [
      /watching now/i,
      /viewers watching/i,
      /en directo/i,
      /live now/i,
      /"isLiveContent":true/i,
      /"isLive":true/i,
      /"videoDetails":[^}]*"isLive":true/i,
      /LIVE/i,
      /üî¥/,
      /"badges":[^]]*"LIVE"/i
    ];

    const isLive = liveIndicators.some(pattern => pattern.test(html));
    console.log('üî¥ Stream en vivo detectado:', isLive);

    // Extraer n√∫mero de viewers con patrones ampliados
    let viewers = 0;
    
    if (isLive) {
      console.log('üîç Buscando viewers para stream en vivo...');
      
      // Patrones para viewers en vivo (mejorados para producci√≥n)
      const viewerPatterns = [
        // Patrones JSON espec√≠ficos
        /"viewCount":{"videoViewCountRenderer":{"viewCount":{"simpleText":"([^"]+)"/,
        /"concurrentViewers":"([^"]+)"/,
        /"videoViewCountRenderer":{"viewCount":{"simpleText":"([^"]+)"/,
        
        // Patrones en texto natural
        /(\d+(?:,\d+)*)\s*watching/i,
        /(\d+(?:,\d+)*)\s*viewers?/i,
        /(\d+(?:\.\d+)?[KMB]?)\s*watching/i,
        /(\d+(?:\.\d+)?[KMB]?)\s*viewers?/i,
        
        // Patrones m√°s espec√≠ficos
        /"viewCount":"([^"]+)"/i,
        /"shortViewCountText":{"simpleText":"([^"]+)"/,
        /watching now.*?(\d+(?:,\d+)*)/i,
        /(\d+(?:,\d+)*)\s*people watching/i,
        
        // Patrones para HTML simplificado (servidores)
        /data-views="([^"]+)"/i,
        /viewers="([^"]+)"/i,
        /"watchingCount":"([^"]+)"/i
      ];

      for (const pattern of viewerPatterns) {
        const match = html.match(pattern);
        if (match) {
          let viewerText = match[1];
          viewers = parseViewerCount(viewerText);
          if (viewers > 0) {
            console.log(`üë• Viewers encontrados con patr√≥n: ${viewerText} ‚Üí ${viewers}`);
            break;
          }
        }
      }

      // Buscar en JSON embebido (mejorado)
      if (viewers === 0) {
        console.log('üîç Buscando en JSON embebido...');
        
        // Buscar m√∫ltiples tipos de JSON
        const jsonPatterns = [
          /var ytInitialData = ({.*?});/,
          /window\["ytInitialData"\] = ({.*?});/,
          /ytInitialData":\s*({.*?}),"/
        ];
        
        for (const jsonPattern of jsonPatterns) {
          const jsonMatch = html.match(jsonPattern);
          if (jsonMatch) {
            try {
              const data = JSON.parse(jsonMatch[1]);
              viewers = findViewersInObject(data);
              if (viewers > 0) {
                console.log(`üë• Viewers encontrados en JSON: ${viewers}`);
                break;
              }
            } catch (e) {
              console.warn('Error parseando JSON pattern:', e);
            }
          }
        }
      }
      
      // √öltimo recurso: buscar n√∫meros grandes en el HTML
      if (viewers === 0) {
        console.log('üîç √öltimo recurso: buscando n√∫meros en HTML...');
        const numberMatches = html.match(/\b(\d{2,})\b/g);
        if (numberMatches) {
          // Buscar n√∫meros que parezcan viewers (entre 10 y 100,000)
          const possibleViewers = numberMatches
            .map(n => parseInt(n, 10))
            .filter(n => n >= 10 && n <= 100000)
            .sort((a, b) => b - a); // Ordenar descendente
            
          if (possibleViewers.length > 0) {
            viewers = possibleViewers[0]; // Tomar el n√∫mero m√°s alto
            console.log(`üë• Viewers estimados por n√∫meros grandes: ${viewers}`);
          }
        }
      }
    } else {
      console.log('üîç Buscando views totales para video grabado...');
      // Para videos no en vivo, buscar views totales
      const viewPatterns = [
        /(\d+(?:,\d+)*)\s*views?/i,
        /(\d+(?:\.\d+)?[KMB]?)\s*views?/i,
        /"viewCount":"([^"]+)"/,
        /"viewCountText":{"simpleText":"([^"]+)"/
      ];

      for (const pattern of viewPatterns) {
        const match = html.match(pattern);
        if (match) {
          viewers = parseViewerCount(match[1]);
          if (viewers > 0) {
            console.log(`üëÅÔ∏è Views encontradas: ${viewers}`);
            break;
          }
        }
      }
    }

    console.log(`üìä Datos extra√≠dos - T√≠tulo: "${title}", Viewers: ${viewers}, Live: ${isLive}`);

    return {
      viewers,
      isLive,
      title,
      status: 'success',
      timestamp: new Date().toISOString(),
      url
    };

  } catch (error) {
    console.error('Error extrayendo datos:', error);
    return {
      viewers: 0,
      isLive: false,
      title: '',
      status: 'error',
      message: 'Error procesando respuesta de YouTube',
      timestamp: new Date().toISOString(),
      url
    };
  }
}

function findTitleInObject(obj: any): string | null {
  if (!obj || typeof obj !== 'object') return null;
  
  const titleKeys = ['title', 'videoTitle', 'name', 'headline'];
  
  for (const key of titleKeys) {
    if (obj[key]) {
      const value = typeof obj[key] === 'object' ? obj[key].simpleText || obj[key].runs?.[0]?.text : obj[key];
      if (value && typeof value === 'string') {
        return value.toString().trim();
      }
    }
  }
  
  // B√∫squeda recursiva
  for (const value of Object.values(obj)) {
    if (typeof value === 'object' && value !== null) {
      const result = findTitleInObject(value);
      if (result) return result;
    }
  }
  
  return null;
}

function findViewersInObject(obj: any): number {
  if (!obj || typeof obj !== 'object') return 0;
  
  const keys = ['concurrentViewers', 'viewCount', 'watching', 'viewers'];
  
  for (const key of keys) {
    if (obj[key]) {
      const value = typeof obj[key] === 'object' ? obj[key].simpleText || obj[key].runs?.[0]?.text : obj[key];
      if (value) {
        const parsed = parseViewerCount(value.toString());
        if (parsed > 0) return parsed;
      }
    }
  }
  
  // B√∫squeda recursiva
  for (const value of Object.values(obj)) {
    if (typeof value === 'object' && value !== null) {
      const result = findViewersInObject(value);
      if (result > 0) return result;
    }
  }
  
  return 0;
}

function parseViewerCount(text: string): number {
  if (!text) return 0;
  
  // Limpiar texto
  text = text.replace(/[^\d,.KMB]/gi, '');
  
  // Manejar notaci√≥n con K, M, B
  const multipliers: { [key: string]: number } = {
    'K': 1000,
    'M': 1000000,
    'B': 1000000000
  };
  
  const match = text.match(/^([\d,.]+)([KMB])?$/i);
  if (match) {
    let number = parseFloat(match[1].replace(/,/g, ''));
    const suffix = match[2]?.toUpperCase();
    
    if (suffix && multipliers[suffix]) {
      number *= multipliers[suffix];
    }
    
    return Math.round(number);
  }
  
  // Fallback: solo n√∫meros
  const numMatch = text.match(/[\d,]+/);
  if (numMatch) {
    return parseInt(numMatch[0].replace(/,/g, ''), 10) || 0;
  }
  
  return 0;
}